docker run -d -p 4111:4111 nobugsme/nbank:with_validation_fix_with_swagger

admin
admin

kate1998
verysTRongPassword33$


# Улучшения
## Skelethon запрос
Идея в том, что конкретные запросы жестко связаны с сущностью, которую они возвращают. Создаем два класса реквестера, в одном приводим к объекту ответ - он нужен для случаев, когда нам нужно проверить поле тела ответа, в другом не приводим - когда нам не нужно проверить тело ответа.
1. Делаем Круд интерфейс - описываем общие методы, которые свойственны конкретному типу эндпоинта
2. Фиксируем жесткую связь эндпоинта и сущности в енаме
   * урл, модель реквеста, модель респонса
     * версию апи выносим в рекспекс
   * не забываем указать конструктор в енаме allargs, и геттерс
   * если в запросе нет тела, можно указать заглушку Object.class
3. Делаем абстракный класс HttpRequest
   * Поля: рекспекс, эндпоинт (енам), респонсспекс
4. Реализовываем КрудРеквестер - для запросов, в которых мы не хотим сразу же сериализовывать ответ в объект, то есть мы получаем ValidatableResponse
   * Имплементируемся от интерфейса Круд
   * Наследуемся от ХттпРеквест - так у мы получаем поля со спеками и эндпоинтом
     * Указать обращение к родительскому конструктору
   * Если модел равно нулл, то тело = ""
5. Реализовываем ВалидейтетКрудРеквестер - для запросов, ответы которых мы хотим сразу сериализовать в объект
   * Делаем поле крудреквестер
   * Также наследуемся от ХттпРеквест, имплементируем Круд интерфейс
   * В конструкторе вызываем родительский конструктор + инициализуруем крудреквестер
   * В методах просто вызываем методы крудреквестера и приводим к нужным типам данных

## Выносим конфигурационные данные в отдельный модуль

1. Создаем в ресурсах файл config.properties
2. Вносим информацию по паттерну `key=value`
   * `url=localhost:8080`
   * `apiVesion=/api/v1/`
3. Создаем класс Config
   * Реализуем паттерн синглтон
     * Создаем статическое поле с самим объектом
     * Закрываем конструктор
   * Создаем поле Properties
   * В конструкторе читаем проперти файл: 35 минута
   * Делаем статик метод вычитки значений из проперти файла
   * В рекспеках урл и тд вытаскиваем из конфига


## Продвинутая генерация тестовых данных
Генерируем сущность не конкретно по полям, а сразу всю сущность. Идея для генерации поля сущности - по регулярке с использованием библиотеки генерации по регулярке.
1. Делаем аннотацию 
   * Метод `regex()`
   * `Retention(RetentionPolicy.RUNTIME)`
   * `Target(ElementType.FIELD)`
2. Добавляем библиотеку rgxgen
3. Создаем класс для генерации
   * Логику подсмотреть в репозитории нобагс и помучать ии

## Сравнение моделей через адаптер
Расширить сравнение моделей в assertj.core, описываем правила в файлике

## Группы запросов
Повторяющиеся группы запросов - есть ряд частоповторяющихся действий, которые требуются для сетапа одного или нескольких тестов, в таком случае, имеет смысл вынести эти шаги в отдельный бизнес модуль, назовем их шаги, типа: Admin steps, User steps. Пример шага: `AdminSteps.createUser()`.
* Логику посмотреть в видео: 1.05


## Оптимизация запроса токена авторизации
1. Преобразуем рекспеки в паттерн синглтон.
   * Закрываем конструктор
2. Создаем статическое хранилище токенов в виде хешмапы
3. В мапу сразу кладем админтокен
4. Когда требуется токен:
   1. идем в хранилище
   2. если токен есть для пользователя, забираем из хранилища
   3. если токена нет, запрашиваем и вносим в хранилище
   * То есть делаем метод authAsUser с входным параметром юзернейм, проверяем есть ли значением под таким юзернеймом в мапе, и далее по алгоритму выше